# css选择器
## 类型选择器（又名元素选择器）   
** 此选择器只是一个选择器名和指定的HTML元素名的不区分大小写的匹配。这是选择所有指定类型的最简单方式。 **

效果链接： http://jsrun.net/qpgKp/edit

## 类选择器
** 类选择器由一个点“.”以及类后面的类名组成。类名是在HTML class文档元素属性中没有空格的任何值。由你自己选择一个名字。同样值得一提的是，文档中的多个元素可以具有相同的类名，而单个元素可以有多个类名(以空格分开多个类名的形式书写)。 **

效果链接: http://jsrun.net/gpgKp/edit

## ID选择器
** ID选择器由哈希/磅符号 (#)组成，后面是给定元素的ID名称。 任何元素都可以使用id属性设置唯一的ID名称。 由你自己选择的ID是什么。 这是选择单个元素的最有效的方式。 **

<strong style='color:red'>重要提示：一个ID名称必须在文件中是唯一的。关于重复ID的行为是不可预测的，比如在一些浏览器只是第一个实例计算，其余的将被忽略。 (在现代浏览器下测试没有发现问题 例如：chrome65 safari 火狐)</strong>

效果链接: http://jsrun.net/XpgKp/edit

## 通用选择器
** 通用选择（*）是最终的王牌。它允许选择在一个页面中的所有元素。 **

<strong style='color:red'>重要提示：使用通用选择时小心。因为它适用于所有的元素，在大型网页利用它可以对性能有明显的影响：网页可以显示比预期要慢。大多数情况下，你都不会使用这个选择器</strong>

效果链接: http://jsrun.net/zpgKp/edit


## 属性选择器 
** 属性选择器是一种特殊类型的选择器，它根据元素的 属性和属性值来匹配元素。它们的通用语法由方括号([]) 组成，其中包含属性名称，后跟可选条件以匹配属性的值。 属性选择器可以根据其匹配属性值的方式分为两类： 存在和值属性选择器和子串值属性选择器。 **

### 存在和值属性选择器
** 这些属性选择器尝试匹配精确的属性值：**
* ```[attr]```: 该选择器选择包含 attr 属性的所有元素，不论 attr 的值为何。
* ```[attr=val]```: 该选择器仅选择 attr 属性被赋值为 val 的所有元素。
* ```[attr~=val]```: 该选择器仅选择具有 attr 属性的元素，而且要求  val 值是  attr 值包含的被空格分隔的取值列表里中的一个时（以空格间隔出多个值）的。

效果链接: http://jsrun.net/PpgKp/edit

### 子串值属性选择器
** 这种情况的属性选择器也被称为“伪正则选择器”，因为它们提供类似 regular expression 的灵活匹配方式（但请注意，这些选择器并不是真正的正则表达式）:**
* ```[attr|=val]```: 选择attr属性的值是 val 或者以 val- 开头的元素（注意，这里的 “-” 不是一个错误，这是用来处理语言编码的）。<strong style='color:red'>注意：只有val时 值只能是 val 不能有多余的字符</strong>
* ```[attr^=val]```: 选择attr属性的值以 val 开头（包括 val）的元素。
* ```[attr$=val]```: 选择attr属性的值以 val 结尾（包括 val）的元素。
* ```[attr^=val]```: 选择attr属性的值中包含子字符串 val 的元素（一个子字符串就是一个字符串的一部分而已，例如，”cat“ 是 字符串 ”caterpillar“ 的子字符串）。

效果链接: http://jsrun.net/dpgKp/edit

## 组合器和选择器组
** 虽然一次使用一个选择器就很有用，但在某些情形中却可能效率低下。 CSS选择器在你开始组合他们进行细粒度选择的时候变得更具使用价值。基于元素之间的相互关联关系，CSS提供了几种方法来对元素进行选择。下表使用连接符展示了这些关联关系(A和B代表任意选择器) : **

| Combinators | Select | 举个栗子 |
| ----------- | --------- | :--------:|
| A,b         | 匹配满足A（和/或）B的任意元素 | [🌰](http://jsrun.net/YigKp/edit) |
| A B         | 匹配任意元素，满足条件：B是A的后代结点（B是A的子节点，或者A的子节点的子节点） |  [🌰](http://jsrun.net/CpgKp/edit)|
| A > b       | 匹配任意元素，满足条件：B是A的直接子节点 |  [🌰](http://jsrun.net/rpgKp/edit)|
| A + b       | 匹配任意元素，满足条件：B是A的下一个兄弟节点（AB有相同的父结点，并且B紧跟在A的后面） |  [🌰](http://jsrun.net/mpgKp/edit) |
| A ~ b       | 匹配任意元素，满足条件：B是A之后的兄弟节点中的任意一个（AB有相同的父节点，B在A之后，但不一定是紧挨着A） |  [🌰](http://jsrun.net/kigKp/edit) |
